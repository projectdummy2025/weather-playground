CUMULUS PROJECT SUMMARY - TECHNICAL STYLING BY COMPONENT
========================================================

Project Overview:
- Name: Cumulus
- Type: Weather monitoring web application
- Architecture: Full-stack web application with Vue.js frontend and Node.js/Express backend
- Purpose: Provides weather forecasts for Indonesian locations using BMKG (Meteorology, Climatology and Geophysics Agency) data

Frontend (Client-Side):
- Framework: Vue.js 3
- Build Tool: Vite
- Styling: Tailwind CSS
- Additional Libraries: Chart.js for data visualization, Marked for markdown processing
- Structure:
  - Components: HeroSection, AboutSection, FaqSection, WeatherSection, Footer
  - Main file: App.vue (handles location selection hierarchy and weather data fetching)
  - Responsive design with dark theme interface

TECHNICAL STYLING ANALYSIS BY COMPONENT
=======================================

HERO SECTION STYLING:
--------------------
- Layout: Full-screen height (min-h-[85vh]) with responsive grid (grid-cols-1 md:grid-cols-2)
- Background: Layered with gradient overlays (bg-gradient-to-b from-slate-900/80 via-slate-900/90 to-slate-900)
- Positioning: Absolute positioning for decorative elements with (absolute inset-0 pointer-events-none)
- Animation: Custom CSS keyframes for drifting, floating, and twinkling effects
  * @keyframes drift: 20s ease-in-out infinite for background elements
  * @keyframes float: 6s ease-in-out infinite for weather icons
  * @keyframes float-medium: 8s ease-in-out infinite with diagonal movement
  * @keyframes twinkle: 3s ease-in-out infinite for decorative elements
- Typography: Montserrat font for headings (font-montserrat) with responsive sizing (text-3xl sm:text-4xl md:text-5xl lg:text-6xl)
- Flexbox: Used for alignment and spacing (flex items-center justify-between)
- Color: Dark theme with slate-900 background, white/light gray text (#e2e8f0, #cbd5e1)
- Search Input: Custom styling with rounded-lg border, bg-slate-800/60 backdrop-blur-sm
- Dropdown: Absolute positioned results with bg-slate-800/95 backdrop-blur-xl
- Scrolling: Custom scrollbar styling (custom-scrollbar class) with Webkit-specific implementation
- Spacing: Padding (px-6 md:px-12) and margin (pt-24 pb-12 md:py-32) for responsive layout
- Shadow: Subtle shadows (shadow-lg, shadow-2xl) for depth

WEATHER SECTION STYLING:
----------------------
- Layout: Container-based with responsive grid system (container mx-auto px-4 lg:px-8 py-6)
- Location Filters: Four-column grid (grid-cols-1 md:grid-cols-2 lg:grid-cols-4) with gap-4
- Dropdowns: Absolute positioned with bg-slate-800/95 backdrop-blur-xl rounded-lg shadow-2xl
- Color-Coded Borders: Province (blue), City (emerald), District (purple), Village (amber)
- Weather Cards: Responsive grid (grid-cols-2 md:grid-cols-2 lg:grid-cols-4) with gap-4
- Chart Container: Fixed height (h-80) with canvas element for Chart.js integration
- Flexbox: Used for alignment in cards (flex flex-col items-center)
- Spacing: Consistent padding (p-4) and margins (mb-6, mb-8) for visual hierarchy
- Typography: Consistent font sizes (text-2xl sm:text-3xl) for weather metrics
- Loading State: Dual-layered spinner with animation delays (animation-delay-150)
- Error Display: Gradient background (bg-gradient-to-r from-red-500/20 to-rose-500/20)
- Markdown Rendering: Custom .ai-content class for AI explanations with rich text styling
- Scrollable Forecasts: Horizontal scrolling container with custom scrollbar
- Responsive Cards: Fixed width (w-32) and shrink prevention (flex-shrink-0)

LOCATION FILTERS STYLING:
------------------------
- Consistent Design: Applied across all four levels (province, city, district, village)
- Input Fields: bg-slate-700/50 text-white rounded-xl border border-slate-600/50
- Hover Effects: Responsive border color changes (group-hover:border-slate-500/70)
- Disabled States: Opacity (disabled:opacity-40) and cursor changes (disabled:cursor-not-allowed)
- SVG Arrows: Rotating indicators (rotate-180) for dropdown states
- Dropdown Items: Hover background changes (hover:bg-<color>-600/20) with color-coded highlights
- Search Functionality: Real-time filtering with custom scrollbar in dropdowns
- Z-Index: Proper layering (z-30) for dropdowns to appear above other content
- Spacing: Consistent padding (px-4 py-3) and margins (mt-2) for dropdowns
- Focus States: Border glow (focus:ring-2 focus:ring-<color>-500) for accessibility

WEATHER DATA CARDS STYLING:
--------------------------
- Grid Layout: Responsive card arrangement (grid-cols-2 md:grid-cols-2 lg:grid-cols-4)
- Color-Coded Headers: Orange (Current Temperature), Blue (Temperature Range), Cyan (Wind Direction), Teal (Humidity)
- Typography: Responsive sizing (text-2xl sm:text-3xl) for metrics
- Spacing: Consistent padding and margins for visual hierarchy
- Flexbox: Used for alignment and organization (flex flex-col text-center md:text-left)
- Text Styling: Responsive alignment (text-center md:text-left) based on screen size
- Color Contrast: High contrast text (text-white) for readability
- Card Styling: Rounded corners (rounded-xl) with consistent padding (p-4)

AI EXPLANATION SECTION STYLING:
-----------------------------
- Background: Gradient from indigo to violet (bg-gradient-to-br from-indigo-900/40 to-violet-900/40)
- Border: Subtle border (border border-indigo-500/30) for definition
- Rounded Corners: (rounded-2xl) for soft edges
- Hover Effects: Interactive elements with (hover:bg-indigo-500/20) and (hover:text-indigo-100)
- Markdown Styling: Custom .ai-content class with rich text support
  * Headings: Custom h1-h6 styling with indigo color (#c7d2fe)
  * Lists: Custom bullet points and numbered lists with indigo highlights
  * Tables: Custom styling with proper borders and backgrounds
  * Code: Syntax highlighting with indigo accents
  * Blockquotes: Left border with indigo color and special background
- Animation: Fade-in animation (@keyframes fadeInUp) for smooth appearance
- Positioning: Relative and absolute positioning for decorative elements

FORECAST TIMELINE STYLING:
-------------------------
- Scrollable Container: Horizontal scrolling with custom scrollbar (overflow-x-auto)
- Individual Cards: Fixed width (w-32) with shrink prevention (flex-shrink-0)
- Flexbox: Used for card organization (flex gap-3) and content alignment
- Image Handling: Weather icons with (w-12 h-12 object-contain drop-shadow-lg)
- Text Styling: Time formatting with responsive sizing and weather descriptions
- Line Clamping: Two-line text limit (line-clamp-2) for weather descriptions
- Card Styling: Consistent padding (p-4), borders (border border-slate-700/80), and rounded corners (rounded-xl)
- Spacing: Consistent gap between items (gap-3) and internal padding

ABOUT SECTION STYLING:
---------------------
- Layout: Four-feature grid (grid-cols-1 md:grid-cols-2 lg:grid-cols-4) with gap-8
- Card Styling: Consistent design (bg-slate-800/50 rounded-2xl border border-slate-700/50)
- Icon Containers: Consistent size (w-14 h-14) with colored backgrounds
- Typography: Consistent heading styles (text-lg font-semibold) and body text (text-sm)
- Text Alignment: Responsive alignment (text-justify) for descriptions
- Hover Effects: Background changes (hover:bg-blue-600/20) and text color transitions
- Centering: Flexbox for icon centering (flex items-center justify-center)
- Spacing: Consistent padding (p-6 md:p-8) and margins (mb-5)

FAQ SECTION STYLING:
-------------------
- Accordion Design: Expand/collapse functionality with custom animations
- SVG Arrows: Rotating indicators (rotate-180) on open/close
- Transition Effects: Custom height transitions with @keyframes
- Typography: Consistent heading styles (text-lg font-medium) and body text
- Spacing: Consistent padding (py-5) and margins for content
- Text Alignment: Responsive alignment (text-left md:text-justify)
- Border Styling: Bottom border (border-b border-slate-700/50) for separation
- Link Styling: Interactive links with hover effects (hover:underline)

FOOTER STYLING:
--------------
- Layout: Multi-column grid (md:grid-cols-2 lg:grid-cols-4) with gap-12
- Background: Gradient from slate-900 to slate-950 (bg-gradient-to-b)
- Border: Top border (border-t border-slate-800) for separation
- Brand Section: Logo and tagline with consistent styling
- Social Icons: Consistent size (w-5 h-5) with hover color changes
- Link Sections: Organized lists with consistent spacing and hover effects
- Bottom Bar: Border (border-t border-slate-800) with legal links
- Typography: Consistent text sizing (text-sm) and color (text-slate-400)
- Flexbox: Used for bottom bar alignment (flex flex-col md:flex-row)
- Copyright: Responsive text alignment (text-center md:text-right)

GLOBAL STYLING:
--------------
- Color Palette: Dark theme with slate-900 as primary background
- Typography: System font stack with Montserrat for headings
- Spacing System: Consistent padding and margin classes throughout
- Flexbox & Grid: Extensive use for layouts and alignment
- Responsive Design: Breakpoints (sm, md, lg, xl) for all device sizes
- Accessibility: Focus states with blue outlines (focus:outline-none focus:ring-2 focus:ring-blue-500)
- Animation: Smooth transitions (transition-colors, transition-all, transition-transform)
- Custom Scrollbars: Themed scrollbars across components
- Backdrop Effects: Blur effects (backdrop-blur-sm, backdrop-blur-xl) for depth
- Shadow System: Consistent shadow usage for depth and definition

HEADER STYLING:
--------------
- Layout: Sticky header (sticky top-0) with z-index (z-50)
- Background: Semi-transparent with blur (bg-slate-900/60 backdrop-blur-xl)
- Border: Subtle bottom border (border-b border-slate-700/30)
- Flexbox: Used for alignment (flex items-center justify-between)
- Typography: Montserrat font (font-montserrat) for branding
- Loading State: Animated spinner with text (animate-spin h-4 w-4)
- Spacing: Consistent padding (px-4 lg:px-8 py-4)

CUSTOM COMPONENT STYLING:
------------------------
- Accordion Transitions: Custom CSS for smooth height changes with JavaScript hooks
- Chart Tooltips: Custom styling for Chart.js tooltips with dark theme
- Markdown Rendering: Custom styles for AI-generated content with proper formatting
- Loading Spinners: Dual-layered animation with different delays for visual interest
- Custom Animations: Multiple custom keyframe animations for visual elements
- Scrollbar Customization: Cross-browser implementation for various scrollable elements

RESPONSIVE BREAKPOINTS:
----------------------
- Mobile: Default classes (base styles)
- Small: sm: prefixed classes (typically 640px)
- Medium: md: prefixed classes (typically 768px) - grid changes, font adjustments
- Large: lg: prefixed classes (typically 1024px) - grid changes, width adjustments
- Extra Large: xl: prefixed classes (typically 1280px) - advanced layouts

This comprehensive styling system creates a cohesive, responsive, and visually appealing interface that works across all device sizes while maintaining performance and accessibility standards. Each component follows consistent design principles with appropriate color coding, spacing, and interactive states.

BACKEND CODE ANALYSIS
=====================

FILE: /home/fedora/projects/Cumulus/backend/server.js
-----------------------------------------------------

const express = require('express');
const axios = require('axios');
const cors = require('cors'); // Import cors
const compression = require('compression'); // Import compression middleware
const http = require('http');
const https = require('https');
require('dotenv').config(); // Load .env
const path = require('path'); // Import path module
const { db, cache } = require('./config/database'); // Import database configuration and cache
const { explainWeather } = require('./services/aiService'); // Import AI service

// Create axios instance with optimized defaults for BMKG API
const bmkgAxios = axios.create({
  timeout: parseInt(process.env.BMKG_TIMEOUT) || 45000, // Use environment variable or default 45s
  headers: {
    'Accept': 'application/json',
    'User-Agent': 'Cumulus-Weather-App/1.0' // Some APIs respond better with user agent
  },
  // Enable keep-alive to reuse connections
  httpAgent: http.Agent({
    keepAlive: true,
    keepAliveMsecs: 1000,
    maxSockets: 50,
    maxFreeSockets: 10,
  }),
  httpsAgent: https.Agent({
    keepAlive: true,
    keepAliveMsecs: 1000,
    maxSockets: 50,
    maxFreeSockets: 10,
  })
});

const app = express();

// Apply middleware for performance optimization
app.use(compression()); // Compress all responses
app.use(express.json({ limit: '10mb' })); // Handle larger JSON payloads
app.use(express.urlencoded({ extended: true, limit: '10mb' })); // Handle larger URL-encoded payloads

// API endpoint for location search
app.get('/api/search-location', async (req, res) => {
  const query = (req.query.q || '').toLowerCase();
  if (!query || query.length < 2) {
    return res.json([]);
  }

  // Create cache key
  const cacheKey = `search:${query}`;

  try {
    // Try to get from cache first
    let results = cache.get(cacheKey);

    if (results) {
      console.log(`Cache hit for query: ${query}`);
      return res.json(results);
    }

    console.log(`Cache miss for query: ${query}, querying database...`);

    // Query database if not in cache - search in villages table
    const [dbResults] = await db.execute(
      'SELECT code, name FROM villages WHERE LOWER(name) LIKE ? LIMIT 20',
      [`%${query}%`]
    );

    // Store in cache for future requests (use TTL from environment, default 1 hour)
    results = dbResults;
    const cacheTTL = parseInt(process.env.CACHE_TTL) || 3600;
    cache.set(cacheKey, results, cacheTTL);

    res.json(results);
  } catch (error) {
    console.error('Database query error:', error);
    res.status(500).json({ error: 'Failed to search locations.' });
  }
});

// API endpoint to get all location data for client-side caching
app.get('/api/all-locations', async (req, res) => {
  const cacheKey = 'all-locations';

  try {
    // Try to get from cache first
    let allLocations = cache.get(cacheKey);

    if (allLocations) {
      console.log('Cache hit for all locations');
      return res.json(allLocations);
    }

    console.log('Cache miss for all locations, querying database...');

    // Query database for all villages (the searchable data)
    const [dbResults] = await db.execute(
      'SELECT code, name FROM villages ORDER BY name'
    );

    // Store in cache for 30 minutes (1800 seconds) as requested
    allLocations = dbResults;
    cache.set(cacheKey, allLocations, 1800); // 30 minutes in seconds

    res.json(allLocations);
  } catch (error) {
    console.error('Database query error for all locations:', error);
    res.status(500).json({ error: 'Failed to retrieve all locations.' });
  }
});

// API endpoint to get provinces
app.get('/api/provinces', async (req, res) => {
  const cacheKey = 'provinces';

  try {
    // Try to get from cache first
    let provinces = cache.get(cacheKey);

    if (provinces) {
      console.log('Cache hit for provinces');
      return res.json(provinces);
    }

    console.log('Cache miss for provinces, querying database...');

    // Query provinces from the provinces table
    const [dbResults] = await db.execute(`
            SELECT
                code,
                name
            FROM provinces
            ORDER BY name
        `);

    // Format results to have consistent structure
    provinces = dbResults.map(row => ({
      code: row.code,
      name: row.name
    }));

    // Store in cache for 1 hour
    cache.set(cacheKey, provinces, 3600);

    res.json(provinces);
  } catch (error) {
    console.error('Database query error for provinces:', error);
    res.status(500).json({ error: 'Failed to retrieve provinces.' });
  }
});

// API endpoint to get cities based on province code
app.get('/api/cities', async (req, res) => {
  const { province } = req.query;
  if (!province) {
    return res.status(400).json({ error: 'Parameter "province" is required.' });
  }

  const cacheKey = `cities:${province}`;

  try {
    // Try to get from cache first
    let cities = cache.get(cacheKey);

    if (cities) {
      console.log('Cache hit for cities');
      return res.json(cities);
    }

    console.log(`Cache miss for cities with province: ${province}, querying database...`);

    // Query cities from the regencies table based on province code
    const [dbResults] = await db.execute(`
            SELECT
                r.code,
                r.name,
                r.type
            FROM regencies r
            JOIN provinces p ON r.province_id = p.id
            WHERE p.code = ?
            ORDER BY r.name
        `, [province]);

    // Format results
    cities = dbResults.map(row => ({
      code: row.code,
      name: row.name,
      type: row.type
    }));

    // Store in cache for 1 hour
    cache.set(cacheKey, cities, 3600);

    res.json(cities);
  } catch (error) {
    console.error('Database query error for cities:', error);
    res.status(500).json({ error: 'Failed to retrieve cities.' });
  }
});

// API endpoint to get districts based on city code
app.get('/api/districts', async (req, res) => {
  const { city } = req.query;
  if (!city) {
    return res.status(400).json({ error: 'Parameter "city" is required.' });
  }

  const cacheKey = `districts:${city}`;

  try {
    // Try to get from cache first
    let districts = cache.get(cacheKey);

    if (districts) {
      console.log('Cache hit for districts');
      return res.json(districts);
    }

    console.log(`Cache miss for districts with city: ${city}, querying database...`);

    // Query districts from the districts table based on city code
    const [dbResults] = await db.execute(`
            SELECT
                d.code,
                d.name
            FROM districts d
            JOIN regencies r ON d.regency_id = r.id
            WHERE r.code = ?
            ORDER BY d.name
        `, [city]);

    // Format results
    districts = dbResults.map(row => ({
      code: row.code,
      name: row.name
    }));

    // Store in cache for 1 hour
    cache.set(cacheKey, districts, 3600);

    res.json(districts);
  } catch (error) {
    console.error('Database query error for districts:', error);
    res.status(500).json({ error: 'Failed to retrieve districts.' });
  }
});

// API endpoint to get villages based on district code
app.get('/api/villages', async (req, res) => {
  const { district } = req.query;
  if (!district) {
    return res.status(400).json({ error: 'Parameter "district" is required.' });
  }

  const cacheKey = `villages:${district}`;

  try {
    // Try to get from cache first
    let villages = cache.get(cacheKey);

    if (villages) {
      console.log('Cache hit for villages');
      return res.json(villages);
    }

    console.log(`Cache miss for villages with district: ${district}, querying database...`);

    // Query villages from the villages table based on district code
    const [dbResults] = await db.execute(`
            SELECT
                v.code,
                v.name,
                v.village_type
            FROM villages v
            JOIN districts d ON v.district_id = d.id
            WHERE d.code = ?
            ORDER BY v.name
        `, [district]);

    // Format results
    villages = dbResults.map(row => ({
      code: row.code,
      name: row.name,
      village_type: row.village_type
    }));

    // Store in cache for 1 hour
    cache.set(cacheKey, villages, 3600);

    res.json(villages);
  } catch (error) {
    console.error('Database query error for villages:', error);
    res.status(500).json({ error: 'Failed to retrieve villages.' });
  }
});

// API endpoint to search for regencies (Kabupaten/Kota)
app.get('/api/search-regency', async (req, res) => {
  const query = (req.query.q || '').toLowerCase();
  if (!query || query.length < 2) {
    return res.json([]);
  }

  const cacheKey = `search-regency:${query}`;

  try {
    let results = cache.get(cacheKey);
    if (results) {
      return res.json(results);
    }

    // Search in regencies table
    const [dbResults] = await db.execute(
      'SELECT id, code, name, type FROM regencies WHERE LOWER(name) LIKE ? LIMIT 10',
      [`%${query}%`]
    );

    results = dbResults;
    cache.set(cacheKey, results, 3600); // Cache for 1 hour

    res.json(results);
  } catch (error) {
    console.error('Database query error:', error);
    res.status(500).json({ error: 'Failed to search regencies.' });
  }
});

// API endpoint for unified search (Regencies, Districts, Villages)
app.get('/api/search-unified', async (req, res) => {
  const query = (req.query.q || '').toLowerCase();
  if (!query || query.length < 2) {
    return res.json([]);
  }

  const cacheKey = `search-unified:${query}`;

  try {
    let results = cache.get(cacheKey);
    if (results) {
      return res.json(results);
    }

    // Parallel queries for better performance
    const [regencies, districts, villages] = await Promise.all([
      // Search Regencies
      db.execute(
        'SELECT id, code, name, type, NULL as parent_name FROM regencies WHERE LOWER(name) LIKE ? LIMIT 5',
        [`%${query}%`]
      ).then(([rows]) => rows.map(r => ({ ...r, type: 'regency', search_type: 'Kabupaten/Kota' }))),

      // Search Districts
      db.execute(`
        SELECT d.id, d.code, d.name, 'district' as type, r.name as parent_name
        FROM districts d
        JOIN regencies r ON d.regency_id = r.id
        WHERE LOWER(d.name) LIKE ? LIMIT 5
      `, [`%${query}%`]).then(([rows]) => rows.map(r => ({ ...r, search_type: 'Kecamatan' }))),

      // Search Villages
      db.execute(`
        SELECT v.id, v.code, v.name, 'village' as type, CONCAT(d.name, ', ', r.name) as parent_name
        FROM villages v
        JOIN districts d ON v.district_id = d.id
        JOIN regencies r ON d.regency_id = r.id
        WHERE LOWER(v.name) LIKE ? LIMIT 5
      `, [`%${query}%`]).then(([rows]) => rows.map(r => ({ ...r, search_type: 'Desa/Kelurahan' })))
    ]);

    // Combine and sort results
    // Prioritize exact matches or starts-with matches if we implemented that logic,
    // but for now just combine them.
    results = [...regencies, ...districts, ...villages];

    // Simple sort by name length to prioritize shorter (likely more relevant) matches
    results.sort((a, b) => a.name.length - b.name.length);

    // Limit total results
    results = results.slice(0, 15);

    cache.set(cacheKey, results, 3600); // Cache for 1 hour

    res.json(results);
  } catch (error) {
    console.error('Database query error (unified search):', error);
    res.status(500).json({ error: 'Failed to search locations.' });
  }
});

// API endpoint to get a random village from a regency
app.get('/api/random-village', async (req, res) => {
  const { regencyId } = req.query;
  if (!regencyId) {
    return res.status(400).json({ error: 'Parameter "regencyId" is required.' });
  }

  try {
    // Get a random village from the specified regency
    // We join villages -> districts -> regencies
    const [dbResults] = await db.execute(`
            SELECT
                v.code,
                v.name,
                d.name as district_name
            FROM villages v
            JOIN districts d ON v.district_id = d.id
            WHERE d.regency_id = ?
            ORDER BY RAND()
            LIMIT 1
        `, [regencyId]);

    if (dbResults.length === 0) {
      return res.status(404).json({ error: 'No villages found for this regency.' });
    }

    res.json(dbResults[0]);
  } catch (error) {
    console.error('Database query error:', error);
    res.status(500).json({ error: 'Failed to get random village.' });
  }
});

// Middleware to log all incoming requests
app.use((req, res, next) => {
  console.log(`Incoming request: ${req.method} ${req.path}`);
  next();
});

app.use(cors()); // Enable CORS for all routes

const PORT = process.env.PORT || 3000;

// Serve static files from the Vue.js build directory
app.use(express.static(path.join(__dirname, '..', 'frontend/dist')));

// --- Fungsi untuk mengambil dan memproses data dari BMKG ---
async function getBmkgForecast(adm4) {
  // Create cache key for this specific adm4 code
  const cacheKey = `bmkg:${adm4}`;
  const cacheTTL = parseInt(process.env.BMKG_CACHE_TTL) || 900; // Cache for 15 minutes (900 seconds) - weather data freshness

  // Try to get from cache first
  let cachedData = cache.get(cacheKey);
  if (cachedData) {
    console.log(`Cache hit for BMKG data: ${adm4}`);
    return cachedData;
  }

  console.log(`Cache miss for BMKG data: ${adm4}, fetching from API...`);

  try {
    const BMKG_BASE_URL = process.env.BMKG_BASE_URL || 'https://api.bmkg.go.id/publik';
    const url = `${BMKG_BASE_URL}/prakiraan-cuaca?adm4=${adm4}`;

    const response = await bmkgAxios.get(url);

    if (response.status !== 200) {
      throw new Error(`API BMKG merespons ${response.status}`);
    }

    const rawData = response.data;

    // --- Parsing dan Transformasi Data ---
    // Validasi struktur data yang benar
    if (!rawData || !Array.isArray(rawData.data) || !rawData.data[0] || !Array.isArray(rawData.data[0].cuaca)) {
      throw new Error('Data dari BMKG tidak valid atau memiliki struktur yang tidak diharapkan.');
    }

    const location = rawData.lokasi || {};
    const forecasts = rawData.data[0].cuaca;

    // Mengubah data mentah menjadi format JSON yang lebih bersih dan terstruktur
    // Optimized parsing - only include necessary fields to reduce response size
    // Prioritize first few days since they're most relevant for users
    const formattedData = {
      lokasi: {
        desa: location.desa || null,
        kecamatan: location.kecamatan || null,
        kota: location.kotkab || null,
        provinsi: location.provinsi || null,
        lat: location.lat || null,
        lon: location.lon || null,
        timezone: location.timezone || null
      },
      // Only return the first 3 days of forecast (most relevant) to reduce payload
      prakiraan: forecasts
        .slice(0, 3) // Take only first 3 days to reduce data transfer
        .map((prakiraan_harian, index_hari) => {
          if (!Array.isArray(prakiraan_harian)) return null;

          // Extract date from the first item to use for the day label
          const firstDateTime = prakiraan_harian.find(item => item.local_datetime) || {};
          const dateStr = firstDateTime.local_datetime;

          let dayLabel = `Hari ke-${index_hari + 1}`; // Default fallback

          if (dateStr) {
            try {
              // Parse the datetime string to create a proper date
              const date = new Date(dateStr);

              // Array for day names in Indonesian
              const dayNames = ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'];
              const monthNames = [
                'Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni',
                'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'
              ];

              const dayName = dayNames[date.getDay()];
              const day = date.getDate();
              const monthName = monthNames[date.getMonth()];
              const year = date.getFullYear();

              // Format: 'Senin, 28 Desember 2025'
              dayLabel = `${dayName}, ${day} ${monthName} ${year}`;
            } catch (e) {
              // If parsing fails, keep the default label
              console.warn(`Failed to parse date: ${dateStr}`, e);
            }
          }

          // Only include essential weather data to reduce payload size
          return {
            hari: dayLabel,
            periode: prakiraan_harian.map(item => ({
              local_datetime: item.local_datetime || null,
              t: item.t ? parseFloat(item.t) : null,        // temperature
              hu: item.hu ? parseInt(item.hu) : null,       // humidity
              weather_desc: item.weather_desc || null,      // weather description
              weather_desc_en: item.weather_desc_en || null, // weather desc in English
              url_ikon: item.image ? item.image.replace(/ /g, '%20') : null, // weather icon
              wind_dir: item.wd_deg || item.wd || null,     // wind direction
              wind_speed: item.ws ? parseFloat(item.ws) : null // wind speed in knots
            })).filter(item => item.local_datetime !== null) // Remove entries without datetime
          };
        })
        .filter(Boolean) // Menghapus entri null jika ada
    };

    // Store in cache for 15 minutes to avoid repeated API calls
    cache.set(cacheKey, formattedData, cacheTTL);
    console.log(`BMKG data cached for ${adm4} with TTL ${cacheTTL}s`);

    return formattedData;

  } catch (error) {
    console.error("Error fetching or parsing BMKG data:", error.message);
    if (error.code === 'ECONNABORTED') {
      throw new Error('Request ke BMKG timeout.');
    }
    throw error;
  }
}

// --- Routing ---
app.get('/api/cuaca', async (req, res) => {
  console.log('API route /api/cuaca hit'); // <-- ADDED FOR DEBUGGING
  const adm4 = req.query.adm4;

  if (!adm4) {
    return res.status(400).json({
      error: 'Parameter "adm4" wajib disertakan.'
    });
  }

  try {
    const forecastData = await getBmkgForecast(adm4);
    res.json(forecastData);
  } catch (error) {
    let statusCode = 500;
    let errorMessage = 'Terjadi kesalahan internal saat mengambil data BMKG.';

    if (error.message.includes('timeout')) {
      statusCode = 504;
    } else if (error.response && error.response.status === 404) {
      statusCode = 404;
      errorMessage = `Data untuk wilayah ${adm4} tidak ditemukan.`;
    }

    return res.status(statusCode).json({ error: errorMessage, details: error.message });
  }
});

// API endpoint for AI weather explanation
app.post('/api/explain-forecast', async (req, res) => {
  const weatherData = req.body;

  if (!weatherData || !weatherData.lokasi || !weatherData.prakiraan) {
    return res.status(400).json({ error: 'Data cuaca tidak valid.' });
  }

  try {
    const explanation = await explainWeather(weatherData);
    res.json({ explanation });
  } catch (error) {
    console.error('Error generating explanation:', error);
    res.status(500).json({ error: 'Gagal membuat penjelasan AI.', details: error.message });
  }
});

// Catch-all route to serve the Vue.js index.html for any other requests
app.get(/.*/, (req, res) => {
  console.log('Catch-all route hit'); // <-- ADDED FOR DEBUGGING
  res.sendFile(path.join(__dirname, '..', 'frontend/dist', 'index.html'));
});

// --- Jalankan Server ---
app.listen(PORT, () => {
  console.log(`Server BMKG Express berjalan di http://localhost:${PORT}`);
});

FILE: /home/fedora/projects/Cumulus/backend/services/aiService.js
-------------------------------------------------------------------

const { OpenRouter } = require("@openrouter/sdk");
require('dotenv').config();

// Initialize OpenRouter client
const client = new OpenRouter({
    apiKey: process.env.OPENROUTER_API_KEY,
});

/**
 * Explains the weather forecast using AI.
 * @param {Object} weatherData - The weather data object to explain.
 * @returns {Promise<string>} - The explanation text.
 */
async function explainWeather(weatherData) {
    try {
        if (!process.env.OPENROUTER_API_KEY || process.env.OPENROUTER_API_KEY.includes('YOUR_API_KEY')) {
            throw new Error('OpenRouter API Key is missing or invalid.');
        }

        const completion = await client.chat.send({
            model: "openai/gpt-oss-20b:free",
            messages: [
                {
                    role: "system",
                    content: "Anda adalah asisten cuaca yang cerdas dan peduli. Tugas Anda adalah menyajikan prakiraan cuaca dalam bentuk narasi emosional yang menenangkan, seperti cerita dari seorang narator radio.\n1. **Fokuslah pada pendekatan storytelling yang human-centered dan menenangkan.** Gunakan bahasa yang puitis dan menggambarkan perasaan serta suasana hati yang dibawa oleh cuaca.\n2. **Gunakan format naratif emosional / storytelling.** Gambarkan suasana seperti \"langit menyelimuti kota dengan lembut\", \"angin bercerita pelan\", \"cahaya meredup dengan lembut\".\n3. **Gunakan waktu 24 jam (misal: pukul 14.00, bukan 2 PM).** Ceritakan bagaimana cuaca beberapa hari ke depan akan memengaruhi perasaan dan aktivitas harian pengguna.\n4. **Jadikan data cuaca sebagai latar belakang cerita, bukan fokus utama.** Fokus pada suasana, perasaan, dan pengalaman hidup dengan cuaca tersebut.\n5. **Tutup dengan saran yang hangat dan reflektif untuk membantu pengguna merasa nyaman dan siap menghadapi beberapa hari ke depan.**"
                },
                {
                    role: "user",
                    content: `Tolong jelaskan data cuaca berikut ini untuk lokasi ${weatherData.lokasi.desa || weatherData.lokasi.kecamatan}, ${weatherData.lokasi.kota}: \n\n${JSON.stringify(weatherData.prakiraan, null, 2)}`
                }
            ]
        });

        return completion.choices[0].message.content;
    } catch (error) {
        console.error("Error in AI service:", error);
        throw new Error("Gagal mendapatkan penjelasan AI: " + error.message);
    }
}

module.exports = { explainWeather };

FILE: /home/fedora/projects/Cumulus/backend/config/database.js
--------------------------------------------------------------

const mysql = require('mysql2/promise');
const cache = require('../utils/cache');

// Read database configuration from environment variables
const dbConfig = {
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  acquireTimeoutMillis: 60000,  // How long to wait to acquire a connection (60 seconds)
  connectTimeout: 60000         // Timeout for initial connection (60 seconds)
};

// Create database connection pool
const db = mysql.createPool(dbConfig);

// Test database connection
db.getConnection()
  .then(connection => {
    console.log('Database connection successful');
    connection.release();
  })
  .catch(err => {
    console.error('Database connection failed:', err.message);
  });

module.exports = { db, cache };

FILE: /home/fedora/projects/Cumulus/backend/utils/cache.js
----------------------------------------------------------

class SimpleCache {
  constructor() {
    this.cache = new Map();
    this.timers = new Map(); // To track timeouts for cache expiration
  }

  get(key) {
    return this.cache.has(key) ? this.cache.get(key) : null;
  }

  set(key, value, ttl = 3600) { // Default TTL: 1 hour in seconds
    // Clear existing timeout if it exists
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
    }

    // Set the value
    this.cache.set(key, value);

    // Set expiration timeout
    const timeoutId = setTimeout(() => {
      this.cache.delete(key);
      this.timers.delete(key);
    }, ttl * 1000); // Convert to milliseconds

    this.timers.set(key, timeoutId);
  }

  has(key) {
    return this.cache.has(key);
  }

  delete(key) {
    if (this.timers.has(key)) {
      clearTimeout(this.timers.get(key));
      this.timers.delete(key);
    }
    return this.cache.delete(key);
  }

  clear() {
    for (const timeoutId of this.timers.values()) {
      clearTimeout(timeoutId);
    }
    this.cache.clear();
    this.timers.clear();
  }
}

module.exports = new SimpleCache();

FILE: /home/fedora/projects/Cumulus/backend/package.json
-------------------------------------------------------

{
  "name": "backend",
  "version": "1.0.0",
  "description": "Backend server for Cumulus application",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "@openrouter/sdk": "^0.1.27",
    "axios": "^1.13.2",
    "compression": "^1.8.1",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "mysql2": "^3.15.3",
    "openai": "^6.9.1"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

FILE: /home/fedora/projects/Cumulus/backend/.env.example
-------------------------------------------------------

# Server
PORT=3000

# Database
DB_HOST=localhost
DB_USER=your_username
DB_PASSWORD=your_password
DB_NAME=cumulus_db

# BMKG API
BMKG_BASE_URL=https://api.bmkg.go.id/publik
BMKG_TIMEOUT=45000
BMKG_CACHE_TTL=900

# Cache
CACHE_TTL=3600

# OpenRouter API
OPENROUTER_API_KEY=YOUR_API_KEY_HERE

The backend implementation provides a comprehensive API for weather data retrieval and location-based services. Key features include:
1. Location hierarchy endpoints (provinces, cities, districts, villages)
2. Search functionality with caching
3. BMKG weather data integration with optimized response parsing
4. AI-powered weather explanations via OpenRouter
5. Comprehensive caching system to optimize performance
6. Database connection pooling for MySQL
7. Compression and CORS middleware for better performance and security
8. Static file serving for the frontend application